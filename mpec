### Hanyi Yi
### Empirical Industrial Organization BLP MPEC codes
### Originally written by Heins in Matlab
### 3/2/2018

############################### functions ###############################
function ind_shnorm(expmeanval,expmu, oo, sharesum, marketForProducts)
    ### Compute the individual probabilities of choosing each product.
    ### The probabilities are those associated with the normally-distributed r.c. logit.

    numer = (expmeanval*oo ).*expmu        # this is the numerator (oo speeds-up expanding mean utility by number of draws)
    sum1 = sharesum*numer
    sum11 = 1./(1+sum1)                    # this is the denominator of the shares
    denom1 = sum11[marketForProducts]      # this expands the denominator
    SS = numer.*denom1                     # simulated shares for each draw
    PROB = mean(SS,2)                      # expected share (i.e. mean across draws)
    return PROB
end

function invertshares(theta2, x, expmeanval, tol_inner, share, v, oo, sharesum, marketForProducts)
    ### GMM objective function for the random coefficients Logit estimated via
    ### the NFP approach proposed by BLP.
    ### Main Purpose: Create reasonable startvalues

    ii = 0
    norm_max = 1
    expmeanval0 = expmeanval

    expmu = exp.(x*Diagonal(vec(theta20))*v)      # exponentiated deviations from mean utilities

    while norm_max > tol_inner && ii < 2500
        expmeanval1 = expmeanval0.*share./ind_shnorm(expmeanval0,expmu, oo, sharesum, marketForProducts)
        t = abs.(expmeanval1-expmeanval0)
        norm_max = maximum(t)
        expmeanval0 = expmeanval1
        ii = ii + 1
    end

    if maximum(isnan.(expmeanval0))<1
         expmeanval = expmeanval0
    end
    delta = log.(expmeanval)
    return delta
end



function jacobian(theta2, x, v, delta, K, numProdsTotal, prods, T, nn, prodsMarket, marketStarts, marketEnds, oo, sharesum, marketForProducts)
    ### Evaluates the Jacobian for the computation of standard errors

    expmu = exp.(x*Diagonal(theta2)*v)      # exponentiated deviations from mean utilities
    expmeanval = exp.(delta)
    simShare, EstShare = ind_shnormMPEC(expmeanval,expmu, oo, sharesum, marketForProducts)

    ooo = ones(1,K+1)

    dSdtheta2 = zeros(numProdsTotal,K+1)
    dSddeltaDIAG = zeros(numProdsTotal,prods)
    dSddelta = zeros(numProdsTotal, numProdsTotal)

    for t=1:T
        index = marketStarts[t]: marketEnds[t]
        ooo1 = ones(prodsMarket[t],1)

        for rr = 1:nn
            if length(index) >1
                dSddeltaDIAG[index,1:prodsMarket[t]] = dSddeltaDIAG[index,1:prodsMarket[t]] + (Diagonal(simShare[index,rr]) - simShare[index,rr]*simShare[index,rr]')/nn
            else
                dSddeltaDIAG[index,1:prodsMarket[t]] = dSddeltaDIAG[index,1:prodsMarket[t]] + (simShare[index,rr] - simShare[index,rr]*simShare[index,rr]')/nn
            end

            dSdtheta2[index,:] = dSdtheta2[index,:] + (simShare[index,rr]*ooo).*(ooo1*v[:,rr]').*( x[index,:] - (ooo1*(simShare[index,rr]'*x[index,:] )))/nn
        end
        dSddelta[index,index] = dSddeltaDIAG[index,1:prodsMarket[t]]
    end

    Ddelta = -inv(dSddelta)*dSdtheta2
    return Ddelta, simShare, EstShare
end

function ind_shnormMPEC(expmeanval,expmu, oo, sharesum, marketForProducts)

    numer = (expmeanval*oo ).*expmu        # this is the numerator (oo speeds-up expanding mean utility by number of draws)
    sum1 = sharesum*numer
    sum11 = 1./(1+sum1)                    # this is the denominator of the shares
    denom1 = sum11[marketForProducts]      # this expands the denominator
    simShare = numer.*denom1
    EstShare = mean(simShare,2)
    return simShare, EstShare
end


############################### Main Program ###############################

#cd("D:\\My Data\\Dropbox\\Spring 2018\\IO\\project\\MyCode")

using DataFrames
using CSV
using JuMP
using Ipopt

iv = Array(readtable(".\\Input\\IV_part1.csv", header = false))
nopurch = Array(readtable(".\\Input\\nopurch_part1.csv", header = false))
prodsMarket = Array(readtable(".\\Input\\prodsMarket_part1.csv", header = false))
share = Array(readtable(".\\Input\\share_part1.csv", header = false))
startvalues = Array(readtable(".\\Input\\startvalues_part1.csv", header = false))
v = Array(readtable(".\\Input\\v_part1.csv", header = false))
x = Array(readtable(".\\Input\\x_part1.csv", header = false))


############################### settings ###############################
nn = 100                       # # draws to simulate shares
tol_inner = 1.e-14             # NFP inner loop tolerance, for starting values here
prods = 25
T = 50
starts = 5                     # # random start values to check during estimation

# market indices tell us the first and last spots of records for each market in
# list of all products
marketStarts = zeros(Int64,T,1)
marketEnds = zeros(Int64,T,1)
marketStarts[1] = 1
marketEnds[1] = prodsMarket[1]
for t=2:T
    marketStarts[t] = marketEnds[t-1] + 1
    marketEnds[t] = marketStarts[t] + prodsMarket[t] - 1
end
numProdsTotal = marketEnds[T]  # Total number of products in all markets
K = size(x)[2]-1               # number of attributes

# create indices to speed share calculations
oo = ones(1,nn)               # index for use in simulation of shares
sharesum = sparse(zeros(T, numProdsTotal))    # used to create denominators in logit predicted shares (i.e. sums numerators)
for t=1:T
    sharesum[t,marketStarts[t]:marketEnds[t]] = 1
end

marketForProducts = zeros(Int64, numProdsTotal,1)   # market indices for each product
#used to expand one logit denominator per consumer to one for each product
for t=1:T
    marketForProducts[marketStarts[t]:marketEnds[t]] = t
end

A = x[:,1:K-1]                                          # product attributes
price=x[:,K+1]                                          # product price
y = log.(share) - log.(nopurch[marketForProducts])     # log-odds ratio for no RC logit estimation
IV = iv

############################### 2SLS ###############################
pz = iv*inv(iv'*iv)*iv'
xhat = pz*x
PX2sls = inv(xhat'*xhat)*xhat'                # project. matrix on weighted x-space for 2SLS
beta2sls = PX2sls*y
se2sls = sqrt.(diag( mean((y-x*beta2sls).^2)*inv(x'*pz*x) ))

############################### GMM ###############################
expmeanval0 = exp.(y)                   # starting value for mean values
W = inv(IV'*IV)                         # GMM weighting matrix
PX = inv(x'*IV*W*IV'*x)*x'*IV*W*IV'     # Used to calculate starting values

############ MPEC Estimation of Random Coefficients Logit Model ################
theta20 = 0.5*abs.(beta2sls)
nIV = size(IV,2)                       # # instrumental variables
objfn = 1.0e20
CPUtMPEC = 0
expmeanval = expmeanval0

# matrices to store values of theta1, theta2, xi and g after optimal solution is found
X_MPEC = zeros(747, starts)
se_theta = zeros(2K+2, starts)
elas = zeros(2, starts)

for reps=1: starts
    theta20 = startvalues[reps,:]          # starting values for standard deviations
    # starting values for mean utilities using BLP inversion
    delta0 = invertshares(theta20, x, expmeanval, tol_inner, share, v, oo, sharesum, marketForProducts)
    # starting values for linear parameters using IV like regression of delta on covariates
    theta10 = PX*delta0
    resid0 = delta0 - x*theta10             # starting values for xi terms]
    g0 = IV'*resid0                         # starting values for GMM moments
    x0 = [theta10; theta20; delta0; g0]     # master starting values, not directly used
    #expmu = exp.(x*Diagonal(theta20)*v)

    mpec = Model(solver=IpoptSolver(jac_c_constant="no",
                                    hessian_constant="no",
                                    mu_strategy="adaptive",
                                    derivative_test="none",
                                    tol=1e-6,
                                    max_iter=100))

    # variables to optimize over
    @variable(mpec, theta1MPEC[i=1:K+1], start = theta10[i])            # mean betas
    @variable(mpec, theta2MPEC[i=1:K+1] >= 0, start = theta20[i])       # std. dev. greater than 0
    @variable(mpec, xiMPEC[i=1:numProdsTotal], start = resid0[i])       # unobs. product characteristics
    @variable(mpec, gMPEC[i=1:nIV], start = g0[i])                          # moments

    # calculate numerator and denominator of the share equation, and calculate simulated market shares
    @NLexpression(mpec,
                  numerator[j=1:numProdsTotal,i=1:nn],
                  exp(sum(x[j,k]*theta1MPEC[k] for k=1:K+1) + xiMPEC[j] + sum(x[j,k]*theta2MPEC[k]*v[k,i] for k=1:K+1)))

    @NLexpression(mpec,
                  denom[t=1:T, i=1:nn],
                  1. + sum(numerator[j,i] for j= marketStarts[t]: marketEnds[t]))

    @NLexpression(mpec,
                  simShare[j=1:numProdsTotal],
                  sum(numerator[j,i]/denom[marketForProducts[j], i] for i=1:nn)/nn)


    # constraints: share condition and moment condition
    for i=1:nIV
        @constraint(mpec,  gMPEC[i] == sum(IV[j,i]*xiMPEC[j] for j=1:numProdsTotal))
    end

    for j=1:numProdsTotal
        @NLconstraint(mpec, share[j] == simShare[j])
    end

    #objective
    @objective(mpec, Min, sum(gMPEC[i]*sum(gMPEC[j]*W[j,i] for j=1:nIV) for i=1:nIV))


    status = solve(mpec)
    objfn_sol = getobjectivevalue(mpec)

    println("Objective value: ", objfn_sol)
    println("theta1 = ", getvalue(theta1MPEC))
    println("theta2 = ", getvalue(theta2MPEC))
    println("g = ", getvalue(gMPEC))

    if(objfn_sol < objfn && status ==:Optimal)
        theta1 = getvalue(theta1MPEC)
        theta2 = getvalue(theta2MPEC)
        xi = getvalue(xiMPEC)
        g = getvalue(gMPEC)
        X_MPEC[:, reps] = vcat(theta1, theta2, xi,g)

        deltaSE = invertshares(theta2, x, expmeanval, tol_inner, share, v, oo, sharesum, marketForProducts)
        resid = deltaSE - x*theta1                         # xi
        delta = deltaSE

        # calculate standard errors
        Ddelta, simShare, EstShare = jacobian(theta2, x, v, delta, K, numProdsTotal, prods, T, nn, prodsMarket, marketStarts, marketEnds, oo, sharesum, marketForProducts)
        covg = zeros(size(IV,2),size(IV,2))
        for ii =1:size(IV,1)
            covg = covg + IV[ii,:]*IV[ii,:]'*(resid[ii]^2)
        end
        Dg = [x Ddelta]'*IV            # gradients of moment conditions
        cov_theta = inv( Dg*W*Dg')*Dg*W*covg*W*Dg'*inv( Dg*W*Dg')
        se_theta[:, reps] = sqrt.(diag(cov_theta))

        # calculate elasticity
        elas_purelogit = theta1[K+1]*(x[:,K+1].*(ones(numProdsTotal)-EstShare[:,1]))
        elas[1,reps] = mean(elas_purelogit)

        elas_rc = x[:,K+1]./EstShare[:,1] .*mean(repmat((theta1[K+1]+theta2[K+1]*v[K+1, :])', 695,1) .*(simShare.*(1-simShare)),2)
        elas[2,reps] = mean(elas_rc)
    end
end

colnames = ["reps1", "reps2", "reps3", "reps4", "reps5"]
CSV.write(".\\Output\\julia_parameters_part1.csv", DataFrame(X_MPEC), colnames=Vector(colnames))
CSV.write(".\\Output\\se_theta_part1.csv", DataFrame(se_theta), colnames=Vector(colnames))
CSV.write(".\\Output\\elasticity_part1.csv", DataFrame(elas), colnames=Vector(colnames))
